/* eslint-disable no-console */
const fs = require('fs')
const path = require('path')

const cds = require('../libx/_runtime/cds')
const DEBUG = cds.debug('mtx')

const { packTarArchive, unpackTarArchive } = require('../lib/utils/resources')
const { collectFiles } = require('../libx/_runtime/extensibility/utils')


const TEMP_DIR = fs.realpathSync(require('os').tmpdir())

module.exports = class ModelProviderService extends cds.Service {

  get _add_stub_methods(){ return true }
  init() {

    // REVISIT: We should do the enforcement only in production
    // let requires = this.definition['@requires_']
    // if (requires && process.env.NODE_ENV === 'production') this.before ('*', req => {
    //   if (!cds.context?.http) return //> not called from external
    //   if (req.user._is_anonymous) return req.reject({ code:401 })
    //   if (!requires.some(r => req.user.is(r))) return req.reject({ code:403 })
    // })

    this.on('getCsn', req => _getCsn(req, false, this._nodejs_models))
    this.on('getExtCsn', req => _getExtCsn(req, this._nodejs_models))
    this.on('getEdmx', async req => {
      const { service, locale, flavor } = req.data
      const csn = await _getCsn(req, false, this._nodejs_models)
      const edmx = cds.compile.to.edmx(csn, { service, flavor })
      const {res} = req._; if (res) res.set('Content-Type', 'application/xml')
      return cds.localize(csn, locale, edmx)
    })

    this.on('getResources', async req => {
      if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')
      // REVISIT: Works only w/o encoding parameter. Default encoding is 'utf8'.
      // try { return await cds.utils.read('resources.tgz') }
      // root is defined in cds.requires, in case of the sidecar scenario it is set to "_main"
      try { return await require('fs').promises.readFile(require('path').resolve(cds.root, conf?.root || '', 'resources.tgz')) }
      catch(e) { if (e.code !== 'ENOENT') throw e }
      const files = Object.keys(await cds.deploy.resources(['*', cds.env.features.folders]))
      if (!files.length) return req.reject(404)
      if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')
      return packTarArchive(files, cds.root)
    })

    this.on('getExtResources', async req => {
      if (!cds.requires.extensibility) return req.reject(400, 'Missing extensibility parameter')
      const rs = await run4 (req.data.tenant, SELECT('sources').from('cds.xt.Extensions'))
      if (!rs.length) return req.reject(404, 'Missing extensions')
      if (rs.every(row => row.sources === null)) return req.reject(404, 'Extension resources not found')
      if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')
      const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
      try {
        await Promise.all (rs.map (row => unpackTarArchive(Buffer.from(JSON.parse(row.sources)), temp, false)))
        return await packTarArchive(collectFiles(temp, ['.csv', '.properties']), temp)
      } finally {
        await (fs.promises.rm || fs.promises.rmdir)(temp, { recursive: true, force: true }).catch(()=>{})
      }
    })

    this.on('isExtended', async req => _isExtended(req.data.tenant))

    this.on('getExtensions', async req => {
      if (!cds.requires.extensibility) return req.reject(400, 'Missing extensibility parameter')
      const exts = await run4 (req.data.tenant, SELECT('csn').from('cds.xt.Extensions'))
      if (!exts.length) return req.reject(404, 'Missing extensions')

      const csn = { extensions: [], definitions: {} }
      exts.forEach(ext => {
        const extCsn = JSON.parse(ext.csn)
        csn.extensions.push(...extCsn.extensions)
        if (extCsn.definitions) csn.definitions = Object.assign(extCsn.definitions, csn.definitions)
      })

      return csn
    })

    this.invalidateCache = tenant => {
      for (const key in this._nodejs_models) {
        if (key.startsWith( `${tenant}:`)) {
          delete this._nodejs_models[key]
        }
      }
    }

    // Conf vars required by getCsn ------------------------------------------
    // eslint-disable-next-line one-var
    const conf = cds.env.requires['cds.xt.ModelProviderService'] || cds.env.requires.kinds['cds.xt.ModelProviderService']
    DEBUG && DEBUG ('ModelProviderService options:', conf)
    const options = {}
    if (conf.root) {
      options.root = path.resolve (cds.root, conf.root)
      options.env = cds.env.for('cds', options.root)
      options.cache = {}
    }
    const fts = cds.env.features.folders
    if (conf.kind !== 'in-sidecar') this._nodejs_models = {}

    /** The implementation for getCsn */
    async function _getCsn (req, checkExt, cache) {
      const { toggles, for:javaornode } = req.data
      const features = !toggles ? [] : toggles === '*' || toggles.includes('*') ? [fts] : toggles.map (f => fts.replace('*',f))
      const isExtended = await _isExtended(req.data.tenant)
      if (checkExt && !isExtended) req.reject(404, 'Missing extensions')
      const hash = `${isExtended ? req.data.tenant : undefined}:${features.join(',')}`
      if (javaornode && cache && cache[hash]) return cache[hash]

      const models = cds.resolve(['*',...features], options)
      if (!models) return

      DEBUG && DEBUG ('loading models from', models)
      let csn = await cds.load(models).then(cds.minify)
      if (isExtended) csn = await _addExtensions(csn, req.data.tenant)
      if (javaornode) csn = cds.compile.for[javaornode](csn)

      // Dirty hack for cds.localize in Node sidecar setup
      Object.defineProperty(csn,'$sources',{ value:csn.$sources, enumerable:true })

      if (javaornode && cache) cache[hash] = csn

      return csn
    }

    async function _getExtCsn (req, cache) {
      if (!cds.requires.extensibility) return req.reject(400, 'Missing extensibility parameter')
      return _getCsn (req, true, cache)
    }   
  }
}


const run4 = (t,q) => t ? cds.tx({tenant:t}, tx => tx.run(q)) : q

/** Add extensions if applicable and exist */
const _addExtensions = async (csn, tenant) => {  
  const exts = await run4 (tenant, SELECT('csn').from('cds.xt.Extensions'))
  if (!exts.length) return csn

  const all = { definitions: {}, extensions: [] }
  for (const each of exts) {
    const ext = JSON.parse(each.csn)
    if (ext.definitions) Object.assign(all.definitions, ext.definitions)
    if (ext.extensions) all.extensions.push(...ext.extensions)
  }
  const extended = cds.compile({
    'base.csn': cds.compile.to.json(csn),
    'ext.csn': cds.compile.to.json(all)
  })
  extended.$sources = csn.$sources // required to load resources like i18n later on

  return extended
}

async function _isExtended (tenant) {
  if (!cds.requires.extensibility) return false
  if (!tenant && cds.requires.multitenancy) return false
  const one = await run4 (tenant, SELECT.one(1).from('cds.xt.Extensions'))
  return !!one
}
