const fs = require('fs')
const path = require('path')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY } = require('../constants')
const BuildTaskHandlerInternal = require('./buildTaskHandlerInternal')

class FeatureToggleBuilder extends BuildTaskHandlerInternal {
    init() {
        this._result = {
            dest: this.task.dest,
            csn: {},
            edmx: new Map(),
            languages: new Set(),
            services: new Set(),
            languageBundles: {}
        }
    }

    get ftsName() {
        return path.dirname(this.env.features.folders || 'fts/*')
    }

    async compileAll(csn, destBase, destFts) {
        const sources = await this._resolveSourcePaths(csn)
        const dictionary = { base: null, features: null }

        if (sources.features) {
            // create base model as the given CSN is containing all features
            dictionary.base = await this.cds.load(sources.base, this.options())
        } else {
            // CSN already represents the base model as no features exist
            dictionary.base = csn
        }
        // preserve @location as @source properties
        await this.compileToJson(dictionary.base, destBase)

        if (sources.features) {
            dictionary.features = await this._compileFeatures(sources.features, destBase, destFts)
        }
        return { dictionary, sources }
    }

    async collectAllLanguageBundles(dictionary, paths, destBase, destFts) {
        // create language bundle for base model
        await this.collectLanguageBundles(dictionary.base, destBase)
        if (dictionary.features) {
            // create language bundles for all features
            for (const ftName in dictionary.features) {
                // attach the sources information for i18n location reference
                dictionary.features[ftName]['$sources'] = paths.features[ftName]
                await this.collectLanguageBundles(dictionary.features[ftName], path.join(destFts, this.ftsName, ftName), false)
            }
        }
    }

    async _resolveSourcePaths(csn) {
        const regex = new RegExp(path.resolve(this.buildOptions.root, this.ftsName).replace(/\\/g, '\\\\') + '[/|\\\\](?<ftName>[^/|\\\\]*)')
        let paths = { base: [] }

        // add ROOT source file paths for the base model
        paths.base = this._resolveModel().reduce((acc, file) => {
            const match = file.match(regex)
            if (!match) {
                acc.push(file)
            }
            return acc
        }, [])

        // keep existing behaviour and return paths returned by cds.resolve if features are not supported by this project
        if (!fs.existsSync(path.join(this.buildOptions.root, this.ftsName))) {
            return paths
        }

        // add source file paths for the features
        paths.features = csn['$sources'].reduce((acc, file) => {
            const match = file.match(regex)
            if (match) {
                const { ftName } = match.groups
                //feature
                if (!acc[ftName]) {
                    acc[ftName] = []
                }
                acc[ftName].push(file)
            }
            return acc
        }, {})

        return paths
    }

    async compileToJson(model, csnDest, saveResult = true) {
        // This will als add a @source prop containing the relative path to the origin .cds source file
        // and a parsed _where clause for @restrict.{grant,where} annotations.
        // The @source annotation is required for correct custom handler resolution if no @impl annotation has been defined as
        // custom service handler implementations are relative to the origin .cds source files.
        // For staging builds (task.src !== task.dest) the csn.json file that is served at runtime is copied into a corresponding srv subfolder.
        // As a consequence the src folder name has to be included in the @source file name while for inplace builds (task.src === task.dest) this is not the case.
        // This ensures that the paths are relative to the cwd when executing cds run.
        const jsonOptions = {
            cwd: this.buildOptions.root,
            src: this.task.src === this.task.dest ? this.task.src : this.buildOptions.root
        }
        const csnStr = this.cds.compile.to.json(model, jsonOptions)
        const csn = JSON.parse(csnStr)
        if (saveResult) {
            this._result.csn = csn
            this._result.csn.meta = model.meta
        }

        // csnDest might be null
        if (csnDest && !this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this.write(csnStr).to(path.join(csnDest, 'csn.json'))
        }
        return csn
    }

    async _compileFeatures(ftsPaths, destBase, destFts) {
        if (!ftsPaths) {
            return
        }
        const features = {}
        const options = { ...this.options(), flavor: 'parsed' }
        const srvFolder = path.relative(destFts, destBase)

        // create feature models
        for (const ftName in ftsPaths) {
            const ftCsn = await this.cds.load(ftsPaths[ftName], options)

            // replace require paths by base model path to ensure precedence of feature annos
            // see https://pages.github.tools.sap/cap/docs/cds/compiler-messages#anno-duplicate-unrelated-layer
            ftCsn.requires = [path.join('../..', srvFolder, 'csn.json')]

            const ftPath = path.join(destFts, this.ftsName, ftName)
            await this.compileToJson(ftCsn, ftPath, false)
            await this._validateFeature(ftPath)
            features[ftName] = ftCsn
        }
        return features
    }

    async _validateFeature(ftPath) {
        // features must not have other than base model dependencies, cross feature dependencies are not supported
        // do not pass options.messages in order to avoid duplicate compiler messages
        return this.cds.load([ftPath])
        // version 2.13.9 of compileSources does not read the requires definition of parsed CSNs
        // require('@sap/cds-compiler').compileSources({ '../..csn.json': baseCsn, 'feature.csn': ftCsn }, this.options())
    }
}

module.exports = FeatureToggleBuilder