"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchServiceBindingForDestination = exports.destinationForServiceBinding = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const environment_accessor_1 = require("../environment-accessor");
const jwt_1 = require("../jwt");
const proxy_util_1 = require("./proxy-util");
const destination_cache_1 = require("./destination-cache");
const destination_from_registration_1 = require("./destination-from-registration");
const service_binding_to_destination_1 = require("./service-binding-to-destination");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'destination-accessor-vcap'
});
/**
 * Tries to build a destination from a service binding with the given name.
 * Throws an error if no services are bound at all, no service with the given name can be found, or the service type is not supported.
 * The last error can be circumvent by using the second parameter to provide a custom function that transforms a service binding to a destination.
 * @param serviceInstanceName - The name of the service.
 * @param options - Options to customize the behavior of this function.
 * @returns A destination.
 * @internal
 */
async function destinationForServiceBinding(serviceInstanceName, options = {}) {
    if (options.useCache) {
        const fromCache = await destination_cache_1.destinationCache.retrieveDestinationFromCache(options.jwt || (0, destination_from_registration_1.decodedJwtOrZid)().subaccountid, serviceInstanceName, destination_cache_1.IsolationStrategy.Tenant);
        if (fromCache) {
            return fromCache;
        }
    }
    const serviceBindings = loadServiceBindings();
    const selected = findServiceByName(serviceBindings, serviceInstanceName);
    const destination = options.serviceBindingTransformFn
        ? await options.serviceBindingTransformFn(selected, options)
        : await transform(selected, options);
    const destWithProxy = destination &&
        ((0, proxy_util_1.proxyStrategy)(destination) === proxy_util_1.ProxyStrategy.INTERNET_PROXY ||
            (0, proxy_util_1.proxyStrategy)(destination) === proxy_util_1.ProxyStrategy.PRIVATELINK_PROXY)
        ? (0, proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
    if (options.useCache) {
        // use the provider tenant if no jwt is given. Since the grant type is clientCredential isolation strategy is tenant.
        await destination_cache_1.destinationCache.cacheRetrievedDestination(options.jwt || (0, destination_from_registration_1.decodedJwtOrZid)().subaccountid, destWithProxy, destination_cache_1.IsolationStrategy.Tenant);
    }
    return destWithProxy;
}
exports.destinationForServiceBinding = destinationForServiceBinding;
function loadServiceBindings() {
    const vcapServices = (0, environment_accessor_1.getVcapService)();
    if (!vcapServices) {
        throw noVcapServicesError();
    }
    return transformServiceBindings(vcapServices);
}
const transformServiceBindings = (vcapService) => {
    const serviceTypes = inlineServiceTypes(vcapService);
    const flattened = flattenServiceBindings(serviceTypes);
    return flattened;
};
function flattenServiceBindings(vcapServices) {
    return (0, util_1.flatten)(Object.values(vcapServices));
}
function inlineServiceTypes(vcapServices) {
    return Object.entries(vcapServices).reduce((vcap, [serviceType, bindings]) => ({
        ...vcap,
        [serviceType]: bindings.map(b => ({ ...b, type: serviceType }))
    }), {});
}
function findServiceByName(serviceBindings, serviceInstanceName) {
    const found = serviceBindings.find(s => s.name === serviceInstanceName);
    if (!found) {
        throw noServiceBindingFoundError(serviceBindings, serviceInstanceName);
    }
    return found;
}
async function transform(serviceBinding, options) {
    if (!service_binding_to_destination_1.serviceToDestinationTransformers[serviceBinding.type]) {
        throw serviceTypeNotSupportedError(serviceBinding.type);
    }
    return service_binding_to_destination_1.serviceToDestinationTransformers[serviceBinding.type](serviceBinding, options);
}
function noVcapServicesError() {
    return Error('No services are bound to the application (environment variable VCAP_SERVICES is not defined)!');
}
function serviceTypeNotSupportedError(serviceType) {
    return Error(`Service of type ${serviceType} is not supported! Consider providing your own transformation function when calling destinationForServiceBinding, like this:
  destinationServiceForBinding(yourServiceName, { serviceBindingToDestination: yourTransformationFunction });`);
}
function noServiceBindingFoundError(serviceBindings, serviceInstanceName) {
    return Error(`Unable to find a service binding for given name "${serviceInstanceName}"! Found the following bindings: ${serviceBindings
        .map(s => s.name)
        .join(', ')}.
      `);
}
/**
 * @internal
 */
async function searchServiceBindingForDestination({ iss, jwt, serviceBindingTransformFn, destinationName, useCache }) {
    logger.debug('Attempting to retrieve destination from service binding.');
    try {
        const jwtFromOptions = iss ? { iss } : jwt ? (0, jwt_1.decodeJwt)(jwt) : undefined;
        const useCacheIgnoringUndefined = typeof useCache !== 'undefined' ? { useCache } : {};
        const destination = await destinationForServiceBinding(destinationName, {
            serviceBindingTransformFn,
            jwt: jwtFromOptions,
            ...useCacheIgnoringUndefined
        });
        logger.info('Successfully retrieved destination from service binding.');
        return destination;
    }
    catch (error) {
        logger.debug(`Could not retrieve destination from service binding. If you are not using SAP Extension Factory, this information probably does not concern you. ${error.message}`);
    }
    return null;
}
exports.searchServiceBindingForDestination = searchServiceBindingForDestination;
//# sourceMappingURL=destination-from-vcap.js.map