const fs = require('fs')
const path = require('path')

const cds = require('../../../libx/_runtime/cds')
const { packArchive, packArchiveCLI, unpackArchive, unpackArchiveCLI } = require('./tar')
const { exists } = require('./utils')

// use tar command line interface
const TEMP_DIR = fs.realpathSync(require('os').tmpdir())

const packTarArchive = async (files, root, flat = false, cli = true) => {
  let tgzBuffer, temp

  try {
    temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
    if (flat) {
      const files_ = []
      for (const file of files) {
        const destination = path.join(temp, path.basename(file))
        await fs.promises.copyFile(file, destination)
        files_.push(destination)
      }
      files = files_
      root = temp
    }

    const relativeFiles = files.map(file => path.relative(root, file))
    if (cli) {
      const output = path.relative(root, path.join(temp, `${cds.utils.uuid()}.tgz`))
      tgzBuffer = await packArchiveCLI(relativeFiles, root, output)
    } else {
      tgzBuffer = await packArchive(relativeFiles, root)
    }
  } finally {
    if (await exists(temp)) {
      await (fs.promises.rm || fs.promises.rmdir)(temp, { recursive: true, force: true })
    }
  }

  return tgzBuffer
}

const unpackTarArchive = async (buffer, folder, cli = true) => {
  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
  const tgz = path.join(temp, 'resources.tgz')
  await fs.promises.writeFile(tgz, Buffer.from(buffer), 'binary')

  try {
    cli ? await unpackArchiveCLI(tgz, folder) : await unpackArchive(tgz, folder)
  } finally {
    if (await exists(temp)) await (fs.promises.rm || fs.promises.rmdir)(temp, { recursive: true, force: true })
  }
}

module.exports = {
  packTarArchive,
  unpackTarArchive
}
