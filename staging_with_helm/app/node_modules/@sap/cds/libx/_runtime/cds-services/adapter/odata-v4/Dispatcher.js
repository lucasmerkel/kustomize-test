const cds = require('../../../cds')
const LOG = cds.log('odata')

const { normalizeError } = require('../../../common/error/frontend')

const _run4 = (tenant, query) => (tenant ? cds.tx({ tenant }, tx => tx.run(query)) : query)
const getError = require('../../../common/error')

// REVISIT: this is always active, even without mtx -> do that better
module.exports = class Dispatcher {
  /**
   * Constructs an Dispatcher for cds service.
   * New OData services will be created.
   *
   * @param service
   */
  constructor(service) {
    this._serviceName = service.definition.name
    this._options = service.options

    this._extMap = new Map()
    this._extMap.set(getModelHash(), createOdataService(service))
    this._intervalMap = new Map()
    this._intervalMap.set(undefined, Date.now())

    if (cds.mtx) {
      cds.mtx._nodejs_models = {}
      cds.mtx.eventEmitter.on(cds.mtx.events.TENANT_UPDATED, async tenant => {
        this._extMap.delete(getModelHash(tenant))
        delete cds.mtx._nodejs_models[tenant]
      })
    }

    this._tenantCheckInterval = cds.requires.extensibility && cds.requires.extensibility.tenantCheckInterval
  }

  _deleteService(tenant) {
    const hash = getModelHash(tenant)
    for (const entry of this._extMap.entries()) {
      if (entry[0].startsWith(hash)) {
        this._extMap.delete(entry[0])
      }
    }
    this._intervalMap.delete(tenant)
  }

  async _checkTenantExt(tenant, last) {
    try {
      const rs = await _run4(tenant, SELECT(1).from('cds.xt.Extensions').where('timestamp >=', last))
      if (!this._mps) this._mps = await cds.connect.to('cds.xt.ModelProviderService')
      if (rs.length) {
        this._deleteService(tenant)
        this._mps.invalidateCache(tenant)
      } else {
        this._intervalMap.set(tenant, Date.now())
      }
    } catch (_) {
      this._deleteService(tenant)
    }
  }

  async _getService4Tenant(req) {
    // here, req is express' req -> req.tenant not available
    const tenant = req.user && req.user.tenant
    const isExtended = await cds.mtx.isExtended(tenant) // REVISIT: avoid await
    if (!isExtended) return false

    let model = cds.mtx._nodejs_models[tenant]
    if (!model) {
      const raw = await cds.mtx.getCsn(tenant)
      model = cds.mtx._nodejs_models[tenant] = cds.compile.for.nodejs(raw)
    }

    const service = await createNewService(this._serviceName, model, this._options)
    service._cdsService._isExtended = true
    return service
  }

  async _getService4(tenant, features) {
    const model = await this._mps.getCsn(tenant, features || [], 'nodejs')
    return createNewService(this._serviceName, model, this._options)
  }

  async _getService(tenant, features, hash, req) {
    if (cds.mtx) {
      const service = await this._getService4Tenant(req)

      if (service) return service

      return this._extMap.get(getModelHash())
    }

    if (!this._mps) this._mps = await cds.connect.to('cds.xt.ModelProviderService')
    const hashBase = getModelHash(undefined, features)
    if (tenant && tenant !== undefined && hash !== hashBase) {
      const isExtended = cds.requires.extensibility && (await this._mps.isExtended(tenant))
      if (isExtended) {
        return this._getService4(tenant, features)
      } else {
        if (!this._extMap.has(hashBase)) {
          this._extMap.set(hashBase, this._getService4(undefined, features))
          this._intervalMap.set(tenant, Date.now())
        }
        return this._extMap.get(hashBase)
      }
    } else {
      return this._getService4(undefined, features)
    }
  }

  async _handleError(err, hash, req, res) {
    if (LOG._error) {
      err.message = 'Unable to get service from service map due to error: ' + err.message
      LOG.error(err)
    }
    // clear map entry
    this._extMap.delete(hash)
    // return 503 to client
    err = getError(Object.assign(err, { statusCode: 503 }))
    const { error } = normalizeError(err, req)

    return res.status(503).send({ error })
  }

  _hasModelProvider() {
    return 'cds.xt.ModelProviderService' in cds.services || 'cds.xt.ModelProviderService' in cds.requires
  }

  /**
   * Dispatch request in case of extensibility to other odata adapters.
   *
   * @param req
   * @param res
   * @private
   * @returns {Promise}
   */
  async dispatch(req, res) {
    // here, req is express' req -> req.tenant not available
    // REVISIT: rethink authentication
    const tenant = req.user && req.user.tenant

    // single tenant w/o features
    if (!cds.mtx && !this._hasModelProvider()) {
      const service = this._extMap.get(getModelHash())
      return service.process(req, res)
    }

    // old mtx does not support feature toggles
    const features = cds.mtx ? [] : _features4(req.features || req.user.features)
    const hash = getModelHash(tenant, features)

    // check for extensions
    if (cds.requires.extensibility && !this._inCheckTenant) {
      this._inCheckTenant = true
      if (this._intervalMap.has(tenant)) {
        const last = this._intervalMap.get(tenant)
        if (Date.now() - last > this._tenantCheckInterval)
          await this._checkTenantExt(tenant, new Date(last).toISOString())
      }
      this._inCheckTenant = false
    }

    // set promise into the map to avoid conflicts
    if (!this._extMap.has(hash)) {
      this._extMap.set(hash, this._getService(tenant, features, hash, req))
      this._intervalMap.set(tenant, Date.now())
    }

    let service
    try {
      service = await this._extMap.get(hash)
    } catch (err) {
      return this._handleError(err, hash, req, res)
    }

    service.process(req, res)
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   *
   * @returns {Function}
   */
  getService() {
    return (req, res) => {
      this.dispatch(req, res)
    }
  }
}

// -----------------------------------------------------
// Private utils...

const OData = require('./OData')
const DEBUG = cds.debug('extensibility')

const { alias2ref } = require('../../../common/utils/csn')

function createOdataService(service) {
  const name = (service.definition && service.definition.name) || service.name
  const edm = cds.compile.to.edm(service.model, { service: name })
  alias2ref(service, edm)

  const odataService = new OData(edm, service.model, service.options)
  odataService.addCDSServiceToChannel(service)

  return odataService
}

async function createNewService(name, model, options) {
  const { constructor: Service, path } = cds.services[name]
  const service = new Service(name, model, { ...options }) // cloning options to be safe
  if (service.init) await service.prepend(service.init)
  if (options.impl) await service.prepend(options.impl)
  if (path) service.path = path
  DEBUG &&
    DEBUG('Created tenant-specific service:', service.name, '= new', Service.name, {
      _handlers: {
        on: service._handlers.on.map(h => ({ on: h.on, handler: () => {} }))
      }
    })
  return createOdataService(service)
}

const getModelHash = (tenant, features) => {
  // ignore tenant in single tenant mode - use default (undefined) hash
  const hash = cds.requires.multitenancy ? `${tenant}:` : 'undefined:'
  return !features ? hash : hash + features.join(';')
}

const _features4 = features => {
  // ensure features is an array
  if (!features) return []
  if (Array.isArray(features)) return features
  if (typeof features === 'string') return features.split(',')
  if (typeof features === 'object')
    return Object.keys(features)
      .filter(k => features[k])
      .sort()
}
